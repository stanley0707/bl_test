# Задание

###Модели

* Пользователи (имя)
* Мероприятия (название, описание и дата проведения)
* Регистрации, связывающие пользователей и мероприятия

 

###api
* Вывод списка мероприятий, в этом списке должно быть отмечено есть ли зарегистрированные пользователи на данное мероприятие или нет.
* Детальный вывод по конкретному мероприятию, в нем должны быть отображены все зарегистрированные на мероприятие пользователи.
* Регистрация на мероприятие, возможность авторизованному пользователю зарегистрироваться на мероприятие.


##Требования
* Приложение должно работать в docker-контейнере и запускаться через docker-compose,
* os можно выбрать любую, но предпочтительней python-slim, версия python не ниже 3.9.
* Добавить покрытие кода тестами (обязательно) и type hints (приветствуется).

========================================================================================

## Что сделано:

Подключена панель администратора, доступна по http://0.0.0.0:8081/admin


Модели данных.

Созданы модели пользователей (таблица 'Account'), событий (таблица 'Event'), промежуточная таблица
осуществляющая свзяь многие ко многим между Account и Event (таблица 'EventAccountInvite'). Вместе с возможностью
записаться на мероприятие, поместить свой Account.id в EventAccountInvite.guest_id соответсвующего Event,
создана таблица Invite, позволяющая всем пользователям участникам отношения Event / Account отправить приглашение Invite
другому пользователю и сохранить это действие.

У каждого аккаунта:
1) cозданные им события покрываются отношением один ко многим как Account.id Event.author_id;

2) у каждого аккаунта не в зависимости от авторства в других событиях есть возможность видеть входящие
непринятые приглашения: состояние его связи EventAccountInvite.is_confirmed ложно,

3) принятые приглашения: EventAccountInvite.is_confirmed = true

4) у каждого пользователя могут быть исходящие приглашения: отношение 
      один к одному Invite с EventAccountInvite,

Функционал.

Наши пользователя деятельные люди, им будет удобно выставлять себе рабочее
время, которое заблокирует приглашение или предупредит пользователя о создании событие не в рабочее время.
Для этого у модели есть json поле work_timing, содержащий паратры рабочей недели:

```
    {
        'Monday': {'start': '10:00', 'end': '18:00', 'break_start': '12:00', 'break_end': '13:00'},
        'Tuesday': {'start': '10:00', 'end': '18:00', 'break_start': '12:00', 'break_end': '13:00'},
        'Wednesday': {'start': '10:00', 'end': '18:00', 'break_start': '12:00', 'break_end': '13:00'},
        'Thursday': {'start': '10:00', 'end': '18:00', 'break_start': '12:00', 'break_end': '13:00'},
        'Friday': {'start': '10:00', 'end': '18:00', 'break_start': '12:00', 'break_end': '13:00'},
    }
``` 

Для валидации времени создан объект 'WorkSchedule'. Его экземляр реализует
ассициативный api сервис для работы с акканутом, например:
```
class Account(BaseMode):
    
    def __init__(self, name: str, work_mapp: dict):
        self.schedule = WorkSchedule(**work_mapp)
        ...


Bob = Account('Bob', bob_week)
Bob.schedule.set_item(
      1,
      datetime(2023, 4, 1, 11, 0),
      datetime(2023, 4, 1, 12, 0),
      BookingType.work,
      'Presentation meeting'
  )
 
```

### REST json API:

Созданы основные методы:

    1) GET  http://0.0.0.0:8081/events/  - возвращает авторизированным
    пользователям массив объектов событий с агрегированными значениями отношений.

    2) GET http://0.0.0.0:8081/events/{event_id} - возвращает авторизированным
    пользователям объект одного события, с содержащимся в нем списка отншений.

    3) GET http://0.0.0.0:8081/events/{event_id}/reg - позволяет авторизированному
    пользователю зарегистрироваться на событие.
    
    4) GET http://0.0.0.0:8081/accounts/ - возвращает авторизированным
    пользователям массив объектов аккаунтов.

    5) GET http://0.0.0.0:8081/accounts/{event_id} - возвращает всем авторизированным
    пользователям объект одного аккаунта, с детализацией его отншений с другими таблицами

    6) GET http://0.0.0.0:8081/accounts/register - позволяет анонимному
    пользователю совершить регистрацию и создать аккаунт.

    7) GET http://0.0.0.0:8081/accounts/login - позволяет анонимному
    пользователю совершить авторизацию и получить JWT токен авторизации.
    
    
Для запуска:

1) первый запуск ```sudo docker-compose build```
2) запуск базы данных  ```sudo docker-compose up -d postgres```, после запуска
   в коре проекта должен собраться том контейнера postgres db_data
3) мердж миграций в базу данны ```source ./run.sh; migrate```
4) запуск проекта  ```sudo docker-compose up```
5) запуск линтера  ```source ./run.sh; lint```

API интерактивной документации быть доступен по http://0.0.0.0:8081/docss


### что не успел:
1) покрыть документацией API
2) недостаточно комментариев к коду   
3) собрать более удобное расположение utils и service объектов,
4) подключить валидацию времени,
5) подключить pytest
6) API недостаточно покрыто исключениями

!!! ВАЖНО !!! Проект асинхронный, что накладыывает сложности в работе с api sqlalchemy:
работа со стандартным api backref зависимостей в асинхронном sqlalchemy осуществляется
только через session.execute, а ленивая загрузка данных в контексте pydantic вызывает
исключения.
